1.Проблема интеграции 3 минуты.
	Монолит - почему плохо
	Микросервисы - почему хорошо и почему сложно.

	All integration solutions have to deal with a few fundamental challenges:
		• Networks are unreliable.
		• Networks are slow.
		• Any two applications are different.
		• Change is inevitable.
	
2. Виды интеграции 3 минут.
	Over time, developers have overcome these challenges with four main approaches:
		1. File Transfer — One application writes a file that another later reads. The applications
		need to agree on the filename and location, the format of the file, the timing of when it
		will be written and read, and who will delete the file.
		2. Shared Database — Multiple applications share the same database schema, located in a
		single physical database. Because there is no duplicate data storage, no data has to be
		transferred from one application to the other.
		3. Remote Procedure Invocation — One application exposes some of its functionality so that it
		can be accessed remotely by other applications as a remote procedure. The
		communication occurs real-time and synchronously.
		4. Messaging — One applications publishes a message to a common message channel. Other
		applications can read the message from the channel at a later time. The applications must 
		agree on a channel as well as the format of the message. The communication is
		asynchronous.

	Messaging is a technology that enables high-speed, asynchronous, program-to-program
	communication with reliable delivery. Programs communicate by sending packets of data called
	messages to each other. Channels, also known as queues, are logical pathways that connect the
	programs and convey messages. A channel behaves like a collection or array of messages, but one
	that is magically shared across multiple computers and can be used concurrently by multiple
	applications. A sender or producer is a program that sends a message by writing the message to a
	channel. A receiver or consumer is a program that receives a message by reading (and deleting) it
	from a channel. 

3. Why messaging? 2 minutes:
	Now that we know what messaging is, we should ask: Why use messaging? As with any
	sophisticated solution, there is no one simple answer. The quick answer is that messaging is more
	immediate than File Transfer, better encapsulated than Shared Database, and more reliable than
	Remote Procedure Invocation. However, that’s just the beginning of the advantages that can be
	gained using messaging.
	Specific benefits of messaging include: 
	• Remote Communication. Messaging enables separate applications to communicate and
	transfer data. Two objects that reside in the same process can simply share the same data
	in memory. Sending data to another computer is a lot more complicated and requires
	data to be copied from one computer to another. This means that objects have to
	"serializable", i.e. they can be converted into a simple byte stream that can be sent across
	the network. If remote communication is not needed, messaging is not needed; a simpler
	solution such as concurrent collections or shared memory is sufficient.
	• Platform/Language Integration.When connecting multiple computer systems via remote
	communication, these systems likely use different languages, technologies and platforms,
	perhaps because they were developed over time by independent teams. Integrating such
	divergent applications can require a demilitarized zone of middleware to negotiate
	between the applications, often using the lowest common denominator—such as flat data
	files with obscure formats. In these circumstances, a messaging system can be a universal
	translator between the applications that works with each one’s language and platform on
	its own terms, yet allows them to all communicate through a common messaging
	paradigm. This universal connectivity is the heart of the Message Bus pattern.
	• Asynchronous Communication. Messaging enables a send and forget approach to
	communication. The sender does not have to wait for the receiver to receive and process
	the message; it does not even have to wait for the messaging system to deliver the
	message. The sender only needs to wait for the message to be sent, e.g. for the message to
	successfully be stored in the channel by the messaging system. Once the message is
	stored, the sender is then free to perform other work while the message is transmitted in
	the background. The receiver may want to send an acknowledgement or result back to
	the sender, which requires another message, whose delivery will need to be detected by a
	callback mechanism on the sender.
	• Variable Timing. With synchronous communication, the caller must wait for the receiver to
	finish processing the call before the caller can receive the result and continue. In this way,
	the caller can only make calls as fast as the receiver can perform them. On the other hand,
	asynchronous communication allows the sender to batch requests to the receiver at its
	own pace, and for the receiver to consume the requests at its own different pace. This
	allows both applications to run at maximum throughput and not waste time waiting on
	each other (at least until the receiver runs out of messages to process).
	• Throttling. A problem with remote procedure calls is that too many of them on a single
	receiver at the same time can overload the receiver. This can cause performance
	degradation and even cause the receiver to crash. Asynchronous communication enables
	the receiver to control the rate at which it consumes requests, so as not to become
	overloaded by too many simultaneous requests. The adverse effect on callers caused by
	this throttling is minimized because the communication is asynchronous, so the callers
	are not blocked waiting on the receiver.
	• Reliable Communication. Messaging provides reliable delivery that a remote procedure call
	(RPC) cannot. The reason messaging is more reliable than RPC is that messaging uses a
	store and forward approach to transmitting messages. The data is packaged as messages,
	which are atomic, independent units. When the sender sends a message, the messaging
	system stores the message. It then delivers the message by forwarding it to the receiver’s 
	computer, where it is stored again. Storing the message on the sender’s computer and the
	receiver’s computer is assumed to be reliable. (To make it even more reliable, the
	messages can be stored to disk instead of memory; see Guaranteed Delivery.) What is
	unreliable is forwarding (moving) the message from the sender’s computer to the
	receiver’s computer, because the receiver or the network may not be running properly.
	The messaging system overcomes this by resending the message until it succeeds. This
	automatic retry enables the messaging system to overcome problems with the network
	such that the sender and receiver don’t have to worry about these details.
	• Disconnected Operation. Some applications are specifically designed to run disconnected
	from the network, yet to synchronize with servers when a network connection is
	available. Such applications are deployed on platforms like laptop computers, PDA’s, and
	automobile dashboards. Messaging is ideal for enabling these applications to
	synchronize—data to be synchronized can be queued as it is created, waiting until the
	application reconnects to the network.
	• Mediation. The messaging system acts as a mediator—as in the Mediator pattern
	[GoF]—between all of the programs that can send and receive messages. An application
	can use it as a directory of other applications or services available to integrate with. If an
	application becomes disconnected from the others, it need only reconnect to the
	messaging system, not to all of the other messaging applications. The messaging system
	can be used to provide a high number of distributed connections to a shared resource,
	such as a database. The messaging system can employ redundant resources to provide
	high-availability, balance load, reroute around failed network connections, and tune
	performance and quality of service.

4. Drawbacks of messaging 3 minutes:
		Asynchronous messaging is not the panacea of integration. It resolves many of the challenges of
		integrating disparate systems in an elegant way but it also introduces new challenges. Some of
		these challenges are inherent in the asynchronous model while other challenges vary with the
		specific implementation of a messaging system.
		• Complex programming model. Asynchronous messaging requires developers to work with
		an event-driven programming model. Application logic can no longer be coded in a
		single method that invokes other methods, but the logic is not split up into a number of
		event handlers that respond to incoming messages. Such a system is more complex and
		harder to develop and debug. For example, the equivalent of a simple method call can
		require a request message and a request channel, a reply message and a reply channel, a
		correlation identifier and an invalid message queue (as described in Request-Reply).
		• Sequence issues. Message channels guarantee message delivery, but they do not guarantee
		when the message will be delivered. This can cause messages that are sent in sequence to
		get out of sequence. In situations where messages depend on each other special care has
		to be taken to re-establish the message sequence.
		• Synchronous scenarios. Not all applications can operate in a send and forget mode. If a user
		is looking for airline tickets, he or she is going to want to see the ticket price right away,
		not after some undetermined time. Therefore, many messaging systems need to bridge
		the gap between synchronous and asynchronous solutions. (See the Request-Reply
		pattern.)
		• Performance. Messaging systems do add some overhead to communication. It takes effort
		to make data into a message and send it, and to receive a message and process it. If you
		have to transport a huge chunk of data, dividing it into a gazillion small pieces may not
		be a smart idea. For example, if an integration solution needs to synchronize information
		between two exiting systems, the first step is usually to replicate all relevant information
		from one system to the other. For such a bulk data replication step, ETL (extract,
		transform, and load) tools are much more efficient than messaging. Messaging is best
		suited to keeping the systems in sync after the initial data replication.
		• Limited platform support. Many proprietary messaging systems are not available on all
		platforms. Often times it is easier to FTP a file to another platform than accessing it via a
		messaging system.
		• Vendor lock-in. Many messaging system implementations rely on proprietary protocols.
		Even common messaging specifications such as JMS do not control the physical
		implementation of the solution. As a result, different messaging systems usually do not
		connect to one another. This can leave you with a whole new integration challenge:
		integrating multiple integration solutions! (See the Messaging Bridge pattern.)
		So asynchronous messaging does not solve all problems, and can even create some new ones.
		Keep these consequences in mind when deciding which problems to solve using messaging.	

3. Брокер сообщений. 3 минуты.
	
	Messaging capabilities are typically provided by a separate software system called a messaging
	system or message-oriented middleware (MOM). A messaging system manages messaging the way a
	database system manages data persistence. Just as an administrator must populate the database
	with the schema for an application’s data, an administrator must configure the messaging system
	with the channels that define the paths of communication between the applications. The
	messaging system then coordinates and manages the sending and receiving of messages. The
	primary purpose of a database is to make sure each data record is safely persisted, and likewise
	the main task of a messaging system is to move messages from the sender’s computer to the
	receiver’s computer in a reliable fashion.
	The reason a messaging system is needed to move messages from one computer to another is that
	computers and the networks that connect them are inherently unreliable. Just because one
	application is ready to send a communication does not mean that the other application is ready to
	receive it. Even if both applications are ready, the network may not be working, or may fail to
	transmit the data properly. A messaging system overcomes these limitations by repeatedly trying
	to transmit the message until it succeeds. Under ideal circumstances, the message is transmitted
	successfully on the first try, but circumstances are often not ideal.
	In essence, a message is transmitted in five steps:
	1. Create — The sender creates the message and populates it with data.
	2. Send — The sender adds the message to a channel.
	3. Deliver — The messaging system moves the message from the sender’s computer to the
	receiver’s computer, making it available to the receiver.
	4. Receive — The receiver reads the message from the channel.
	5. Process — The receiver extracts the data from the message. 

4.Мастранзит введение. 3 minutes
5. Pub/Sub 3 minutes
6. Topology 2 minutes
7. Структура сообщения Masstransit. 3 minutes
8. Exceptions 3 minutes.
9. Saga - 5 minutes.
10. Courier 5 minutes

Total 30 min



Ideas:

concurrency - птенцы


Patterns:

